{"version":3,"sources":["../src/sticky.js"],"names":["PropTypes","React","ReactDOM","monitoredEventNames","Sticky","$children","$placeholder","childMetrics","placeholderMetrics","containerOffset","undefined","distanceFromBottom","height","width","xOffset","propKeys","state","updateContext","inherited","node","$containerNode","getBoundingClientRect","bottom","recomputeState","captureMetrics","isSticky","setState","handleUpdateDOM","channel","update","data","offset","props","onStickyStateChange","refs","children","placeholder","Object","keys","on","context","subscribe","newProps","newState","length","valuesChanged","some","key","hasOwnProperty","off","unsubscribe","topOffset","isActive","stickyClassName","stickyStyle","bottomOffset","left","distanceFromTop","top","topBreakpoint","bottomBreakpoint","distanceFromTo","placeholderStyle","paddingBottom","style","transform","position","bottomLimit","classList","events","callback","forEach","evt","window","addEventListener","removeEventListener","Component","propTypes","number","className","string","bool","func","object","defaultProps","contextTypes","any"],"mappings":"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","file":"sticky.js","sourcesContent":["import PropTypes from 'prop-types';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst monitoredEventNames = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\n\nexport default class Sticky extends React.Component {\n  static propTypes = {\n    bottomOffset: PropTypes.number,\n    className: PropTypes.string,\n    isActive: PropTypes.bool,\n    onStickyStateChange: PropTypes.func,\n    stickyClassName: PropTypes.string,\n    stickyStyle: PropTypes.object,\n    style: PropTypes.object,\n    topOffset: PropTypes.number,\n  };\n\n  static defaultProps = {\n    bottomOffset: 0,\n    className: '',\n    isActive: true,\n    onStickyStateChange: () => {},\n    stickyClassName: 'sticky',\n    stickyStyle: {},\n    style: {},\n    topOffset: 0,\n  };\n\n  static contextTypes = {\n    'sticky-channel': PropTypes.any\n  };\n\n  $children = null;\n  $placeholder = null;\n\n  childMetrics = null;\n  placeholderMetrics = null;\n\n  containerOffset = undefined;\n  distanceFromBottom = null;\n  height = null;\n  width = null;\n  xOffset = null;\n\n  propKeys = null;\n  state = {};\n\n  componentDidMount() {\n    this.$children = this.refs.children;\n    this.$placeholder = this.refs.placeholder;\n    this.propKeys = Object.keys(this.props);\n\n    this.on(monitoredEventNames, this.recomputeState);\n    this.recomputeState();\n\n    this.channel = this.context['sticky-channel'];\n    this.channel.subscribe(this.updateContext);\n  }\n\n  componentWillReceiveProps() {\n    this.recomputeState();\n  }\n\n  shouldComponentUpdate(newProps, newState) {\n    // Have we changed the number of props?\n    if (Object.keys(newProps).length != this.propKeys.length) return true;\n\n    // Have we changed any prop values?\n    const valuesChanged = this.propKeys.some((key) => newProps.hasOwnProperty(key) && newProps[key] !== this.props[key]);\n    if (valuesChanged) return true;\n\n    // Have we changed any state that will always impact rendering?\n    if (newState.isSticky !== this.state.isSticky) return true;\n\n    return false;\n  }\n\n  componentDidUpdate() {\n    this.propKeys = Object.keys(this.props);\n  }\n\n  componentWillUnmount() {\n    this.off(monitoredEventNames, this.recomputeState);\n    this.channel.unsubscribe(this.updateContext);\n\n    this.$children = null;\n    this.$containerNode = null;\n    this.$placeholder = null;\n  }\n\n  render() {\n    const {\n      topOffset,\n      isActive,\n      stickyClassName,\n      stickyStyle,\n      bottomOffset,\n      onStickyStateChange,\n      ...props\n    } = this.props;\n\n    return (\n      <div>\n        <div ref=\"placeholder\" />\n        <div {...props} ref=\"children\">\n          {this.props.children}\n        </div>\n      </div>\n    );\n  }\n\n  captureMetrics() {\n    this.childMetrics = this.$children.getBoundingClientRect();\n    this.placeholderMetrics = this.$placeholder.getBoundingClientRect();\n\n    this.height = this.childMetrics.height;\n    this.width = this.placeholderMetrics.width;\n    this.xOffset = this.placeholderMetrics.left;\n    this.distanceFromTop = this.placeholderMetrics.top;\n  }\n\n  isSticky() {\n    if (!this.props.isActive) return false;\n\n    const topBreakpoint = this.containerOffset - this.props.topOffset;\n    const bottomBreakpoint = this.containerOffset + this.props.bottomOffset;\n\n    return this.distanceFromTo <= topBreakpoint && this.distanceFromBottom >= bottomBreakpoint;\n  }\n\n  handleUpdateDOM() {\n    const placeholderStyle = { paddingBottom: 0 };\n\n    // To ensure that this component becomes sticky immediately on mobile devices instead\n    // of disappearing until the scroll event completes, we add `transform: translateZ(0)`\n    // to 'kick' rendering of this element to the GPU\n    // @see http://stackoverflow.com/questions/32875046\n    let style = { transform: 'translateZ(0)', ...this.props.style };\n\n    if (this.state.isSticky) {\n      const stickyStyle = {\n        position: 'fixed',\n        top: this.containerOffset,\n        left: this.xOffset,\n        width: this.width\n      };\n\n      const bottomLimit = this.distanceFromBottom - this.height - this.props.bottomOffset;\n      if (this.containerOffset > bottomLimit) {\n        stickyStyle.top = bottomLimit;\n      }\n\n      placeholderStyle.paddingBottom = this.height;\n\n      style = Object.assign({}, style, stickyStyle, this.props.stickyStyle);\n    }\n\n    this.$children.classList[this.state.isSticky ? 'add' : 'remove'](this.props.stickyClassName);\n    Object.assign(this.$children.style, style);\n\n    Object.assign(this.$placeholder.style, placeholderStyle);\n  }\n\n  updateContext = ({ inherited, node }) => {\n    if (!this.$containerNode) {\n      this.$containerNode = node;\n    }\n\n    if (inherited !== this.containerOffset) {\n      this.containerOffset = inherited;\n      this.distanceFromBottom = this.$containerNode.getBoundingClientRect().bottom;\n\n      this.recomputeState();\n    }\n  };\n\n  recomputeState = () => {\n    this.captureMetrics();\n\n    const isSticky = this.isSticky();\n\n    if (this.state.isSticky !== isSticky) {\n      this.setState({ isSticky }, this.handleUpdateDOM);\n\n      if (this.channel) {\n        this.channel.update((data) => {\n          data.offset = (isSticky ? this.height : 0);\n        });\n      }\n\n      this.props.onStickyStateChange(isSticky);\n    } else {\n      this.handleUpdateDOM();\n    }\n  };\n\n  on(events, callback) {\n    events.forEach((evt) => {\n      window.addEventListener(evt, callback, true);\n    });\n  }\n\n  off(events, callback) {\n    events.forEach((evt) => {\n      window.removeEventListener(evt, callback, true);\n    });\n  }\n}\n"]}